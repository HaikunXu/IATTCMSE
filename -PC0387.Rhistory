fig.height = 6, fig.width = 12)
# Chunk 2: initial_setup
library(tidyr)
library(dplyr)
library(ggplot2)
library(knitr)
#Specify path of parent directory
pdir <- "D:/OneDrive - IATTC/IATTC/2026/MSE/Demo/"
# Dimensions
niterations <- 6
nyears <- 21
Mcycle <- 3
nsteps <- nyears / Mcycle
model = c("Fix", "Gro", "Sel", "Mrt")
catchability = c(1, 1.01, 1.02)
steepness = c(1, 0.9, 0.8)
converge <- array(1, dim = c(length(model), length(catchability), length(steepness)))
# converge[1, 3, 3] <- 0
# converge[4, 2, 2:3] <- 0
OM_list <- data.frame(expand.grid(
model = model,
catchability = catchability,
steepness = steepness
))
OM_list$converge <- converge[1:36]
OM_list <- OM_list %>% filter(converge == 1)
OM_name <- paste0(OM_list$model, "-", OM_list$catchability, "-", OM_list$steepness)
Check_list <- data.frame(
HSnum = c(1, 1, 1, 1, 1),
HCR_name = c("HCR_0", "HCR_7", "HCR_8", "HCR_3", "HCR_9"),
HS_plot = c("HS_Fix", "HS_Fix", "HS_Fix", "HS_Fix",  "HS_Fix"),
HCR_plot = c("HCR_staff", "HCR_40_40_nocap", "HCR_40_40_10cap", "HCR_30_30_nocap", "HCR_40_40_20cap")
)[1,]
# Chunk 3: management_output
for (i in 1:nrow(Check_list)) {
# Set the HCR
HCR <- paste0(Check_list$HCR_name[i], "/")
HS <- paste0("HS", Check_list$HSnum[i], "/")
for (OMnum in 1:length(OM_name)) {
# Set the scenario
OM <- paste0(OM_name[OMnum], "/")
# extract saved management output
for (itrnum in 1:niterations) {
itr = paste0("itr", itrnum, "/")
skip_to_next <- FALSE
tryCatch({
Record <- read.csv(paste0(paste0(
pdir, HS, HCR, OM, itr, "Record.csv"
)))
Record$Step <- 1:nrow(Record)
Record$OM <- OM_name[OMnum]
Record$itr <- itrnum
Record$HCR <- Check_list$HCR_plot[i]
Record$HS <- Check_list$HS_plot[i]
Record$Model <- stringr::str_split(OM_name[OMnum], "-",  simplify = TRUE)[1]
Record$Catchability <- stringr::str_split(OM_name[OMnum], "-",  simplify = TRUE)[2]
Record$Steepness <- stringr::str_split(OM_name[OMnum], "-",  simplify = TRUE)[3]
if (i == 1 & OMnum == 1 & itrnum == 1)
Record_all <- Record
else
Record_all <- rbind(Record_all, Record)
}, error = function(e) {
skip_to_next <<- TRUE
})
if (skip_to_next) {
next
}
}
}
}
Record_all_count <- Record_all %>%
filter(Step == nsteps, max_gradient < 0.1) %>%
group_by(HS, HCR, OM) %>%
summarise(count = n())
kable(Record_all_count,caption = "Record_all_count")
Record_all_failed <- Record_all %>%
filter(Step == nsteps) %>%
filter(max_gradient > 0.1 | is.na(max_gradient)) %>%
select(OM, itr) %>%
mutate(Flag = 0)
kable(Record_all_failed,caption = "Record_all_failed")
Record_all <- left_join(Record_all, Record_all_failed) %>%
filter(is.na(Flag))
Record_all$itr <- as.factor(Record_all$itr)
Record_all$Step <- as.factor(Record_all$Step)
Record_all$HCR <- as.factor(Record_all$HCR)
# Chunk 4
for (i in 1:nrow(Check_list)) {
# Set the HCR
HCR <- paste0(Check_list$HCR_name[i], "/")
HS <- paste0("HS", Check_list$HSnum[i], "/")
for (OMnum in 1:length(OM_name)) {
# Set the scenario
OM <- paste0(OM_name[OMnum], "/")
for (itrnum in 1:niterations) {
itr = paste0("itr", itrnum, "/")
skip_to_next <- FALSE
tryCatch({
Output <- read.csv(paste0(paste0(pdir, HS, HCR, OM, itr, "Output.csv")))
Output$OM <- OM_name[OMnum]
Output$itr <- itrnum
Output$HCR <- Check_list$HCR_plot[i]
Output$HS <- Check_list$HS_plot[i]
Output$Model <- strsplit(OM_name[OMnum], "-")[[1]][1]
Output$Catchability <- strsplit(OM_name[OMnum], "-")[[1]][2]
Output$Steepness <- strsplit(OM_name[OMnum], "-")[[1]][3]
if (i == 1 & OMnum == 1 & itrnum == 1)
Output_all <- Output
else
Output_all <- rbind(Output_all, Output)
}, error = function(e) {
skip_to_next <<- TRUE
})
if (skip_to_next) {
next
}
}
}
}
Output_all <- Output_all %>%
mutate(itr = as.factor(itr),
Year = Year / 4 + 1974.875,
year = floor(Year) + 0.5)
Output_MSE <- Output_all %>% filter(year > 2025)
# Chunk 5: SBR_d
ggplot(data = Output_MSE) +
geom_point(aes(x = Year, y = SBR_d, color = Model), alpha = 0.2, size = 1) +
facet_wrap(~HCR) +
geom_hline(yintercept = 0.2, linetype = "dashed") +
# geom_hline(yintercept = 0.3, linetype = "dashed") +
geom_vline(xintercept = 2025 + seq(Mcycle, nyears - Mcycle, Mcycle), linetype = "dashed") +
ylab("Dynamic SBR") +
theme_bw()
SBR_d <- Output_MSE %>%
group_by(HS, HCR, Year) %>%
summarise(low = quantile(SBR_d, 0.1, na.rm = TRUE),
medium = mean(SBR_d, na.rm = TRUE),
high = quantile(SBR_d, 0.9, na.rm = TRUE))
ggplot(data = SBR_d) +
geom_ribbon(aes(x = Year, ymin = low, ymax = high, fill = HCR), alpha = 0.2) +
geom_line(aes(x = Year, y = medium, color = HCR), linewidth = 1.5) +
geom_hline(yintercept = 0.4, linetype = "dashed") +
geom_hline(yintercept = 0.3, linetype = "dashed") +
# facet_wrap(~ HS) +
ylab("Dynamic SBR") +
geom_vline(xintercept = 2025 + seq(Mcycle, nyears - Mcycle, Mcycle), linetype = "dashed") +
theme_bw()
# SBR_d_OM <- Output_MSE %>%
#   group_by(HS, HCR, Year, Model) %>%
#   mutate(low = quantile(SBR_d, 0.1, na.rm = TRUE),
#          medium = mean(SBR_d, na.rm = TRUE),
#          high = quantile(SBR_d, 0.9, na.rm = TRUE))
#
# ggplot(data = SBR_d_OM) +
#   geom_ribbon(aes(x = Year, ymin = low, ymax = high, fill = Model), alpha = 0.2) +
#   geom_line(aes(x = Year, y = medium, color = Model), linewidth = 1) +
#   # geom_hline(yintercept = 0.2) +
#   geom_hline(yintercept = 0.2, linetype = "dashed") +
#   facet_wrap( ~ HCR) +
#   ylab("Dynamic SBR") +
#   geom_vline(xintercept = 2025 + seq(Mcycle, nyears - Mcycle, Mcycle), linetype = "dashed") +
#   theme_bw()
SBR_d_q <- Output_MSE %>%
group_by(HS, HCR, Year, Catchability) %>%
mutate(low = quantile(SBR_d, 0.1, na.rm = TRUE),
medium = mean(SBR_d, na.rm = TRUE),
high = quantile(SBR_d, 0.9, na.rm = TRUE))
ggplot(data = SBR_d_q) +
geom_ribbon(aes(x = Year, ymin = low, ymax = high, fill = Catchability), alpha = 0.2) +
geom_line(aes(x = Year, y = medium, color = Catchability), linewidth = 1) +
# geom_hline(yintercept = 0.2) +
geom_hline(yintercept = 0.2, linetype = "dashed") +
facet_wrap( ~ HCR) +
ylab("Dynamic SBR") +
geom_vline(xintercept = 2025 + seq(Mcycle, nyears - Mcycle, Mcycle), linetype = "dashed") +
theme_bw()
p_SBR_d <- Output_MSE %>%
mutate(check = SBR_d < 0.2) %>%
group_by(HS, HCR) %>%
summarise(p = sum(check)/ n())
kable(p_SBR_d,caption = "p(SBR_d) < 0.2")
ggplot(data = Output_MSE) +
geom_violin(aes(x = HCR, y = SBR_d, color = HCR), draw_quantiles = c(0.1, 0.5, 0.9)) +
geom_hline(yintercept = 0.2, linetype = "dashed") +
# facet_wrap(~ HS) +
theme_bw()
library(r4ss)
library(IATTCassessment)
Path1 <- "C:/Users/Model6/Desktop/EM/Plot.R/"
Path1 <- "C:/Users/Model6/Desktop/EM/Plot.R/"
myreplist1 = SS_output(dir=Path1,covar=T)
Path1 <- "C:/Users/Model6/Desktop/EM/"
myreplist1 = SS_output(dir=Path1,covar=T)
SS_plots(replist=myreplist1, forecastplot=T, uncertainty=T, datplot=T, btarg=0, minbthresh=0)
###################
Path1 <- "C:/Users/Model6/Desktop/EM/"
Path2 <- "C:/Users/Model6/Desktop/EM - Copy/"
mod.sum <- SSsummarize(list(Myreplist1, Myreplist2))
#
SSplotComparisons(mod.sum, legendlabels = c("EM", "EM - Copy"),
print = TRUE, plotdir = Path1,
minbthresh = 0, btarg = 0)
myreplist1 = SS_output(dir=Path1,covar=T)
myreplist2 = SS_output(dir=Path2,covar=T)
mod.sum <- SSsummarize(list(Myreplist1, Myreplist2))
mod.sum <- SSsummarize(list(myreplist1, myreplist2))
#
SSplotComparisons(mod.sum, legendlabels = c("EM", "EM - Copy"),
print = TRUE, plotdir = Path1,
minbthresh = 0, btarg = 0)
Path1 <- "C:/Users/Model6/Desktop/EM/ - Copy"
myreplist1 = SS_output(dir=Path1,covar=T)
SS_plots(replist=myreplist1, forecastplot=T, uncertainty=T, datplot=T, btarg=0, minbthresh=0)
Path1 <- "C:/Users/Model6/Desktop/EM/ - Copy"
myreplist1 = SS_output(dir=Path1,covar=T)
Path1 <- "C:/Users/Model6/Desktop/EM - Copy/"
myreplist1 = SS_output(dir=Path1,covar=T)
SS_plots(replist=myreplist1, forecastplot=T, uncertainty=T, datplot=T, btarg=0, minbthresh=0)
Dynamic_Bzero <- myreplist1$Dynamic_Bzero
SBR_d <- Dynamic_Bzero$SSB[nrow(Dynamic_Bzero)] / Dynamic_Bzero$SSB_nofishing[nrow(Dynamic_Bzero)]
Dynamic_Bzero <- myreplist2$Dynamic_Bzero
SBR_d <- Dynamic_Bzero$SSB[nrow(Dynamic_Bzero)] / Dynamic_Bzero$SSB_nofishing[nrow(Dynamic_Bzero)]
Dynamic_Bzero <- myreplist1$Dynamic_Bzero
SBR_d <- Dynamic_Bzero$SSB[nrow(Dynamic_Bzero)] / Dynamic_Bzero$SSB_nofishing[nrow(Dynamic_Bzero)]
View(Dynamic_Bzero)
Dynamic_Bzero <- myreplist2$Dynamic_Bzero
SBR_d <- Dynamic_Bzero$SSB[nrow(Dynamic_Bzero)] / Dynamic_Bzero$SSB_nofishing[nrow(Dynamic_Bzero)]
Dynamic_Bzero1 <- myreplist1$Dynamic_Bzero; Dynamic_Bzero2 <- myreplist2$Dynamic_Bzero
View(Dynamic_Bzero2)
View(Dynamic_Bzero1)
Path1 <- "C:/Users/Model6/Desktop/EM/"
myreplist1 = SS_output(dir=Path1,covar=T)
Dynamic_Bzero <- myreplist1$Dynamic_Bzero
SBR_d <- Dynamic_Bzero$SSB[nrow(Dynamic_Bzero)] / Dynamic_Bzero$SSB_nofishing[nrow(Dynamic_Bzero)]
Dynamic_Bzero <- myreplist2$Dynamic_Bzero
SBR_d <- Dynamic_Bzero$SSB[nrow(Dynamic_Bzero)] / Dynamic_Bzero$SSB_nofishing[nrow(Dynamic_Bzero)]
Dynamic_Bzero <- myreplist2$Dynamic_Bzero
SBR_d <- Dynamic_Bzero$SSB[nrow(Dynamic_Bzero)] / Dynamic_Bzero$SSB_nofishing[nrow(Dynamic_Bzero)]
Dynamic_Bzero <- myreplist2$Dynamic_Bzero
SBR_d <- Dynamic_Bzero$SSB[nrow(Dynamic_Bzero)] / Dynamic_Bzero$SSB_nofishing[nrow(Dynamic_Bzero)]
Dynamic_Bzero <- myreplist2$Dynamic_Bzero
SBR_d <- Dynamic_Bzero$SSB[nrow(Dynamic_Bzero)] / Dynamic_Bzero$SSB_nofishing[nrow(Dynamic_Bzero)] * 1.163170077
Dynamic_Bzero <- myreplist1$Dynamic_Bzero
SBR_d <- Dynamic_Bzero$SSB[nrow(Dynamic_Bzero)] / Dynamic_Bzero$SSB_nofishing[nrow(Dynamic_Bzero)] * 1.163170077
library(IATTCMSE)
library(dplyr)
library(foreach)
library(doParallel)
# Specify path of parent directory
pdir <- "D:/OneDrive - IATTC/IATTC/2026/MSE/Demo/"
# Specify the path of conditioned initial OM
sdir <- "D:/OneDrive - IATTC/IATTC/2025/Update_Assessment/F40/"
# Dimensions
niterations <- 6
nyears <- 21
nquarters <- nyears * 4
Mcycle <- 3
nsteps <- nyears / Mcycle
endquarter <- 200
startquarter <- 17
n_extra_R <- 2 # number of assessment period recruitment in the projection
EM_comp_fleet <- c(4, 23) # fleets with comps in ASPM Rdevs+
dat_name <- "BET-EPO.dat"
ctl_name <- "BET-EPO.ctl"
ss_name <- "ss.exe"
model = c("Fix", "Gro", "Sel", "Mrt")
catchability = c(1, 1.01, 1.02)
steepness = c(1, 0.9, 0.8)
converge <- array(1, dim = c(length(model), length(catchability), length(steepness)))
# converge[1, 3, 3] <- 0
# converge[4, 2, 2:3] <- 0
OM_list <- data.frame(expand.grid(
Model = model,
Catchability = catchability,
Steepness = steepness
))
OM_list$converge <- converge[1:36]
OM_list <- OM_list %>% filter(converge == 1)
OM_name <- paste0(OM_list$Model, "-", OM_list$Catchability, "-", OM_list$Steepness)
OM <- paste0(OM_name, "/")
HCR_name <- "HCR_10"
HCR <- paste0(HCR_name, "/")
# Set the harvest strategy
HSnum <- 1
HS <- paste0("HS", HSnum, "/")
# dir.create(paste0(pdir, HS)) # for that harvest strategy
for (OMnum in 1:length(OM)) {
# create a folder for all iterations
# unlink(paste0(pdir, HS, HCR, OM[OMnum]), recursive = TRUE)
dir.create(paste0(pdir, HS, HCR, OM[OMnum])) # for that OM
}
Weight_M <- data.frame("Model" = model, "Weight_M" =  rep(1 / length(model), length(model)))
Weight_Q <- data.frame("Catchability" = catchability, "Weight_Q" = rep(1 / length(catchability), length(catchability)))
Weight_S <- data.frame("Steepness" = steepness, "Weight_S" = c(0.46, 0.32, 0.22))
# specify the run list
runs <- data.frame(expand.grid(
Model = model,
Catchability = catchability,
itr = 1:niterations
))
runs$Steepness <- NA
Weight_tot <- left_join(left_join(left_join(OM_list,Weight_M),Weight_Q),Weight_S) %>%
group_by(Model, Catchability) %>%
mutate(Weight_S2 = Weight_S / sum(Weight_S) * niterations)
for (m in 1:length(model)) {
for (q in 1:length(catchability)) {
Weight_1 <- Weight_tot %>% filter(Model == model[m], Catchability == catchability[q], Steepness == 1)
Weight_0.9 <- Weight_tot %>% filter(Model == model[m], Catchability == catchability[q], Steepness == 0.9)
Weight_0.8 <- Weight_tot %>% filter(Model == model[m], Catchability == catchability[q], Steepness == 0.8)
n_1 <- round(sum(Weight_1$Weight_S2, na.rm = TRUE))
n_0.9 <- round(sum(Weight_0.9$Weight_S2, na.rm = TRUE))
runs$Steepness[which(runs$Model==model[m]&runs$Catchability==catchability[q])][1:n_1] <- 1
if(n_1 < niterations) runs$Steepness[which(runs$Model==model[m]&runs$Catchability==catchability[q])][(n_1+1):(n_1+n_0.9)] <- 0.9
if(n_1 + n_0.9 < niterations) runs$Steepness[which(runs$Model==model[m]&runs$Catchability==catchability[q])][(n_1+n_0.9+1):niterations] <- 0.8
}
}
counts <- runs %>% group_by(Model, Catchability, Steepness) %>% summarise(n=n())
runs$OM <- paste0(runs$Model, "-", runs$Catchability, "-", runs$Steepness, "/")
# runs <- runs %>% filter(OM == "Fix-1-1/")
# Calculate the numbers of cores
no_cores = 12 # detectCores() - 2
# Initiate cluster
cl = makeCluster(no_cores)
registerDoParallel(cl)
# *************************************************************************************
# step 1: initialize the OM by copying from the benchmark assessment model
# *************************************************************************************
foreach(i = 1:length(OM_name)) %dopar% {
IATTCMSE::Initialize_OM(pdir, sdir, HS, HCR, OM[i], dat_name, ctl_name, ss_name)
}
# i = 25; OM = runs[i, 5]; itrnum = runs[i, 3];
# clean = TRUE; plot = FALSE; MSY = FALSE
# IATTCMSE::BET_MSE(pdir,sdir,HS,HCR = HCR,OM = runs[i, 5],itrnum = runs[i, 3],
#   nquarters,Mcycle,n_extra_R,startquarter,endquarter, EM_comp_fleet,
#   dat_name,ctl_name,ss_name,
#   clean = TRUE,plot = FALSE,MSY = FALSE
# )
# run the MSE
foreach(i = 1:nrow(runs)) %dopar% {
IATTCMSE::BET_MSE(
pdir,
HS,
HCR,
OM = runs[i, 5],
itrnum = runs[i, 3],
nquarters,
Mcycle,
n_extra_R,
startquarter,
endquarter,
EM_comp_fleet,
dat_name,
ctl_name,
ss_name,
Scontrol = 0.3,
clean = TRUE,
plot = FALSE,
MSY = TRUE
)
}
library(IATTCMSE)
library(dplyr)
library(foreach)
library(doParallel)
# Specify path of parent directory
pdir <- "D:/OneDrive - IATTC/IATTC/2026/MSE/Demo/"
# Specify the path of conditioned initial OM
sdir <- "D:/OneDrive - IATTC/IATTC/2025/Update_Assessment/F40/"
# Dimensions
niterations <- 6
nyears <- 21
nquarters <- nyears * 4
Mcycle <- 3
nsteps <- nyears / Mcycle
endquarter <- 200
startquarter <- 17
n_extra_R <- 2 # number of assessment period recruitment in the projection
EM_comp_fleet <- c(4, 23) # fleets with comps in ASPM Rdevs+
dat_name <- "BET-EPO.dat"
ctl_name <- "BET-EPO.ctl"
ss_name <- "ss.exe"
model = c("Fix", "Gro", "Sel", "Mrt")
catchability = c(1, 1.01, 1.02)
steepness = c(1, 0.9, 0.8)
converge <- array(1, dim = c(length(model), length(catchability), length(steepness)))
# converge[1, 3, 3] <- 0
# converge[4, 2, 2:3] <- 0
OM_list <- data.frame(expand.grid(
Model = model,
Catchability = catchability,
Steepness = steepness
))
OM_list$converge <- converge[1:36]
OM_list <- OM_list %>% filter(converge == 1)
OM_name <- paste0(OM_list$Model, "-", OM_list$Catchability, "-", OM_list$Steepness)
OM <- paste0(OM_name, "/")
HCR_name <- "HCR_10"
HCR <- paste0(HCR_name, "/")
# Set the harvest strategy
HSnum <- 1
HS <- paste0("HS", HSnum, "/")
# dir.create(paste0(pdir, HS)) # for that harvest strategy
for (OMnum in 1:length(OM)) {
# create a folder for all iterations
# unlink(paste0(pdir, HS, HCR, OM[OMnum]), recursive = TRUE)
dir.create(paste0(pdir, HS, HCR, OM[OMnum])) # for that OM
}
Weight_M <- data.frame("Model" = model, "Weight_M" =  rep(1 / length(model), length(model)))
Weight_Q <- data.frame("Catchability" = catchability, "Weight_Q" = rep(1 / length(catchability), length(catchability)))
Weight_S <- data.frame("Steepness" = steepness, "Weight_S" = c(0.46, 0.32, 0.22))
# specify the run list
runs <- data.frame(expand.grid(
Model = model,
Catchability = catchability,
itr = 1:niterations
))
runs$Steepness <- NA
Weight_tot <- left_join(left_join(left_join(OM_list,Weight_M),Weight_Q),Weight_S) %>%
group_by(Model, Catchability) %>%
mutate(Weight_S2 = Weight_S / sum(Weight_S) * niterations)
for (m in 1:length(model)) {
for (q in 1:length(catchability)) {
Weight_1 <- Weight_tot %>% filter(Model == model[m], Catchability == catchability[q], Steepness == 1)
Weight_0.9 <- Weight_tot %>% filter(Model == model[m], Catchability == catchability[q], Steepness == 0.9)
Weight_0.8 <- Weight_tot %>% filter(Model == model[m], Catchability == catchability[q], Steepness == 0.8)
n_1 <- round(sum(Weight_1$Weight_S2, na.rm = TRUE))
n_0.9 <- round(sum(Weight_0.9$Weight_S2, na.rm = TRUE))
runs$Steepness[which(runs$Model==model[m]&runs$Catchability==catchability[q])][1:n_1] <- 1
if(n_1 < niterations) runs$Steepness[which(runs$Model==model[m]&runs$Catchability==catchability[q])][(n_1+1):(n_1+n_0.9)] <- 0.9
if(n_1 + n_0.9 < niterations) runs$Steepness[which(runs$Model==model[m]&runs$Catchability==catchability[q])][(n_1+n_0.9+1):niterations] <- 0.8
}
}
counts <- runs %>% group_by(Model, Catchability, Steepness) %>% summarise(n=n())
runs$OM <- paste0(runs$Model, "-", runs$Catchability, "-", runs$Steepness, "/")
# runs <- runs %>% filter(OM == "Fix-1-1/")
# Calculate the numbers of cores
no_cores = 12 # detectCores() - 2
# Initiate cluster
cl = makeCluster(no_cores)
registerDoParallel(cl)
# *************************************************************************************
# step 1: initialize the OM by copying from the benchmark assessment model
# *************************************************************************************
foreach(i = 1:length(OM_name)) %dopar% {
IATTCMSE::Initialize_OM(pdir, sdir, HS, HCR, OM[i], dat_name, ctl_name, ss_name)
}
# i = 25; OM = runs[i, 5]; itrnum = runs[i, 3];
# clean = TRUE; plot = FALSE; MSY = FALSE
# IATTCMSE::BET_MSE(pdir,sdir,HS,HCR = HCR,OM = runs[i, 5],itrnum = runs[i, 3],
#   nquarters,Mcycle,n_extra_R,startquarter,endquarter, EM_comp_fleet,
#   dat_name,ctl_name,ss_name,
#   clean = TRUE,plot = FALSE,MSY = FALSE
# )
# run the MSE
foreach(i = 1:nrow(runs)) %dopar% {
IATTCMSE::BET_MSE(
pdir,
HS,
HCR,
OM = runs[i, 5],
itrnum = runs[i, 3],
nquarters,
Mcycle,
n_extra_R,
startquarter,
endquarter,
EM_comp_fleet,
dat_name,
ctl_name,
ss_name,
Scontrol = 0.3,
clean = TRUE,
plot = FALSE,
MSY = TRUE
)
}
stopCluster(cl)
# Chunk 1: setup
knitr::opts_chunk$set(echo = FALSE, warning = FALSE,
fig.height = 6, fig.width = 12)
# Chunk 2: initial_setup
library(tidyr)
library(dplyr)
library(ggplot2)
library(knitr)
#Specify path of parent directory
pdir <- "D:/OneDrive - IATTC/IATTC/2026/MSE/Demo/"
# Dimensions
niterations <- 6
nyears <- 21
Mcycle <- 3
nsteps <- nyears / Mcycle
model = c("Fix", "Gro", "Sel", "Mrt")
catchability = c(1, 1.01, 1.02)
steepness = c(1, 0.9, 0.8)
converge <- array(1, dim = c(length(model), length(catchability), length(steepness)))
# converge[1, 3, 3] <- 0
# converge[4, 2, 2:3] <- 0
OM_list <- data.frame(expand.grid(
model = model,
catchability = catchability,
steepness = steepness
))
OM_list$converge <- converge[1:36]
OM_list <- OM_list %>% filter(converge == 1)
OM_name <- paste0(OM_list$model, "-", OM_list$catchability, "-", OM_list$steepness)
Check_list <- data.frame(
HSnum = c(1, 1, 1, 1, 1),
HCR_name = c("HCR_10", "HCR_7", "HCR_8", "HCR_3", "HCR_9"),
HS_plot = c("HS_Fix", "HS_Fix", "HS_Fix", "HS_Fix",  "HS_Fix"),
HCR_plot = c("HCR_40_30_10cap", "HCR_40_40_nocap", "HCR_40_40_10cap", "HCR_30_30_nocap", "HCR_40_40_20cap")
)[1,]
