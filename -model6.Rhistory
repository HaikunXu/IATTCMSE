HSnum <- 1
HS <- paste0("HS", HSnum, "/")
# Set the HCR
HCRnum <- 2
HCR <- paste0(HCR_name[HCRnum], "/")
# Set the scenario
OMnum <- 1
OM <- paste0(OM_name[OMnum], "/")
# create a folder for all iterations
dir.create(paste0(pdir, HS)) # for that harvest strategy
dir.create(paste0(pdir, HS, HCR)) # for that harvest control rule
dir.create(paste0(pdir, HS, HCR, OM)) # for that OM
# BET_MSE(pdir, sdir, HS, HCR, OM, itrnum = 1, nquarters, Mcycle, n_extra_R, startquarter, endquarter, EM_comp_fleet)
#Calculate the numbers of cores
no_cores = 5 # detectCores() - 2
#Initiate cluster
cl = makeCluster(no_cores)
registerDoParallel(cl)
foreach(itrnum = 1:niterations) %dopar% { IATTCMSE::BET_MSE(pdir, sdir, HS, HCR, OM, itrnum, nquarters, Mcycle, n_extra_R, startquarter, endquarter, EM_comp_fleet) }
stopCluster(cl)
library(IATTCMSE)
library(foreach)
library(doParallel)
# Specify path of parent directory
pdir <- "D:/OneDrive - IATTC/IATTC/2025/MSE/Test/"
# Specify the path of conditioned initial OM
sdir <- "D:/OneDrive - IATTC/IATTC/2025/SAC16/BET F30/"
# Dimensions
niterations <- 5
nyears <- 15
nquarters <- nyears * 4
Mcycle <- 3
nsteps <- nyears / Mcycle
endquarter <- 196
startquarter <- 17
n_extra_R <- 2 # number of assessment period recruitment in the projection
EM_comp_fleet <- NA # c(4, 23) # fleets with comps in ASPM Rdevs+
# simulate and save recruitment devs
# set.seed(123)
# seeds <- sample(1:1e3, size = niterations, replace = FALSE)  # Sample 5 elements without replacement
# write.csv(seeds, file = paste0(pdir,"seeds.csv"), row.names = FALSE)
#
# R_devs <- matrix(NA, nrow = nquarters, ncol = niterations)
# for (i in 1:niterations) {
#   set.seed(seeds[i])
#   R_devs[,i] <- rnorm(n = nquarters, mean = 0, sd = 0.6) - 0.6 ^ 2 / 2
# }
#
# write.csv(R_devs, file = paste0(pdir,"R_devs.csv"), row.names = FALSE)
# Calculate the numbers of cores
no_cores = 10 # detectCores() - 2
# Initiate cluster
cl = makeCluster(no_cores)
registerDoParallel(cl)
OM_name <- c("Fix-1-1", "Sel-1-1", "Gro-1-1", "Mrt-1-1")
OM <- paste0(OM_name, "/")
HCR_name <- c("HCR_staff", "HCR_staff_0", "HCR_staff_0_Fscaler")
# Set the harvest strategy
HSnum <- 1
HS <- paste0("HS", HSnum, "/")
dir.create(paste0(pdir, HS)) # for that harvest strategy
# Set the HCR
HCRnum <- 3
HCR <- paste0(HCR_name[HCRnum], "/")
dir.create(paste0(pdir, HS, HCR)) # for that harvest control rule
# specify the run list
runs <- data.frame(expand.grid(run_om = OM, run_itr = 1:niterations))
for (OMnum in 1:4) {
# create a folder for all iterations
unlink(paste0(pdir, HS, HCR, OM[OMnum]), recursive = TRUE)
dir.create(paste0(pdir, HS, HCR, OM[OMnum])) # for that OM
}
BET_MSE(pdir, sdir, HS, HCR, runs[i,1], runs[i,2], nquarters, Mcycle, n_extra_R, startquarter, endquarter, EM_comp_fleet, clean = TRUE)
library(IATTCMSE)
library(foreach)
library(doParallel)
# Specify path of parent directory
pdir <- "D:/OneDrive - IATTC/IATTC/2025/MSE/Test/"
# Specify the path of conditioned initial OM
sdir <- "D:/OneDrive - IATTC/IATTC/2025/SAC16/BET F30/"
# Dimensions
niterations <- 5
nyears <- 15
nquarters <- nyears * 4
Mcycle <- 3
nsteps <- nyears / Mcycle
endquarter <- 196
startquarter <- 17
n_extra_R <- 2 # number of assessment period recruitment in the projection
EM_comp_fleet <- NA # c(4, 23) # fleets with comps in ASPM Rdevs+
# simulate and save recruitment devs
# set.seed(123)
# seeds <- sample(1:1e3, size = niterations, replace = FALSE)  # Sample 5 elements without replacement
# write.csv(seeds, file = paste0(pdir,"seeds.csv"), row.names = FALSE)
#
# R_devs <- matrix(NA, nrow = nquarters, ncol = niterations)
# for (i in 1:niterations) {
#   set.seed(seeds[i])
#   R_devs[,i] <- rnorm(n = nquarters, mean = 0, sd = 0.6) - 0.6 ^ 2 / 2
# }
#
# write.csv(R_devs, file = paste0(pdir,"R_devs.csv"), row.names = FALSE)
# Calculate the numbers of cores
no_cores = 10 # detectCores() - 2
# Initiate cluster
cl = makeCluster(no_cores)
registerDoParallel(cl)
OM_name <- c("Fix-1-1", "Sel-1-1", "Gro-1-1", "Mrt-1-1")
OM <- paste0(OM_name, "/")
HCR_name <- c("HCR_staff", "HCR_staff_0", "HCR_staff_0_Fscaler")
# Set the harvest strategy
HSnum <- 1
HS <- paste0("HS", HSnum, "/")
dir.create(paste0(pdir, HS)) # for that harvest strategy
# Set the HCR
HCRnum <- 3
HCR <- paste0(HCR_name[HCRnum], "/")
dir.create(paste0(pdir, HS, HCR)) # for that harvest control rule
# specify the run list
runs <- data.frame(expand.grid(run_om = OM, run_itr = 1:niterations))
for (OMnum in 1:4) {
# create a folder for all iterations
unlink(paste0(pdir, HS, HCR, OM[OMnum]), recursive = TRUE)
dir.create(paste0(pdir, HS, HCR, OM[OMnum])) # for that OM
}
# BET_MSE(pdir, sdir, HS, HCR, runs[i,1], runs[i,2], nquarters, Mcycle, n_extra_R, startquarter, endquarter, EM_comp_fleet, clean = TRUE)
foreach(i = 1:nrow(runs)) %dopar% { IATTCMSE::BET_MSE(pdir, sdir, HS, HCR, runs[i,1], runs[i,2], nquarters, Mcycle, n_extra_R, startquarter, endquarter, EM_comp_fleet, clean = TRUE) }
library(IATTCMSE)
library(foreach)
library(doParallel)
# Specify path of parent directory
pdir <- "D:/OneDrive - IATTC/IATTC/2025/MSE/Test/"
# Specify the path of conditioned initial OM
sdir <- "D:/OneDrive - IATTC/IATTC/2025/SAC16/BET F30/"
# Dimensions
niterations <- 5
nyears <- 15
nquarters <- nyears * 4
Mcycle <- 3
nsteps <- nyears / Mcycle
endquarter <- 196
startquarter <- 17
n_extra_R <- 2 # number of assessment period recruitment in the projection
EM_comp_fleet <- NA # c(4, 23) # fleets with comps in ASPM Rdevs+
# simulate and save recruitment devs
# set.seed(123)
# seeds <- sample(1:1e3, size = niterations, replace = FALSE)  # Sample 5 elements without replacement
# write.csv(seeds, file = paste0(pdir,"seeds.csv"), row.names = FALSE)
#
# R_devs <- matrix(NA, nrow = nquarters, ncol = niterations)
# for (i in 1:niterations) {
#   set.seed(seeds[i])
#   R_devs[,i] <- rnorm(n = nquarters, mean = 0, sd = 0.6) - 0.6 ^ 2 / 2
# }
#
# write.csv(R_devs, file = paste0(pdir,"R_devs.csv"), row.names = FALSE)
# Calculate the numbers of cores
no_cores = 10 # detectCores() - 2
# Initiate cluster
cl = makeCluster(no_cores)
registerDoParallel(cl)
OM_name <- c("Fix-1-1", "Sel-1-1", "Gro-1-1", "Mrt-1-1")
OM <- paste0(OM_name, "/")
HCR_name <- c("HCR_staff", "HCR_staff_0", "HCR_staff_0_Fscaler")
# Set the harvest strategy
HSnum <- 1
HS <- paste0("HS", HSnum, "/")
dir.create(paste0(pdir, HS)) # for that harvest strategy
# Set the HCR
HCRnum <- 3
HCR <- paste0(HCR_name[HCRnum], "/")
dir.create(paste0(pdir, HS, HCR)) # for that harvest control rule
# specify the run list
runs <- data.frame(expand.grid(run_om = OM, run_itr = 1:niterations))
for (OMnum in 1:4) {
# create a folder for all iterations
unlink(paste0(pdir, HS, HCR, OM[OMnum]), recursive = TRUE)
dir.create(paste0(pdir, HS, HCR, OM[OMnum])) # for that OM
}
i = 1; OM = runs[i,1]; itrnum = runs[i,2]
itr = paste0("itr", itrnum, "/")
# create and set directory for each iteration (i.e. different recruitment)
dir_itr <- paste0(pdir, HS, HCR, OM, itr)
dir.create(dir_itr)
nsteps <- nquarters / 4 / Mcycle
R_devs <- read.csv(paste0(pdir,"R_devs.csv"))[, itrnum] # R devs for the itr iteration
seed <- read.csv(paste0(pdir,"seeds.csv"))[itrnum, 1]
SBR_d_ts <- rep(NA, nsteps)
max_gradient_ts <- rep(NA, nsteps)
Closure_ts <- rep(NA, nsteps)
Fadjust_ts <- rep(NA, nsteps)
F30_ts <- rep(NA,  nsteps)
Time_ts <- rep(NA, nsteps)
SB_ts <- rep(NA, nsteps)
# *************************************************************************************
# step 1: initialize the OM by copying from the benchmark assessment model
# *************************************************************************************
step1 <- IATTCMSE::Initialize_OM(pdir, sdir, HS, HCR, OM)
Flag <- 1 # mark whether the loop is running without an EM with a large gradient
for (istep in 1:nsteps){
# print(paste0(pdir, HS, HCR, OM, itr, ": istep = ",istep))
# specify the previous OM and EM directories
if(istep == 1) {
dir_OM_previous <- paste0(pdir, HS, HCR, OM, "itr0/")
dir_EM_previous <- paste0(pdir, HS, "EM/")
CurrentClosure <- 72
}
else {
dir_OM_previous <- paste0(pdir, HS, HCR, OM, itr, "step", istep - 1, "/OM_Boot/")
dir_EM_previous <- paste0(pdir, HS, HCR, OM, itr, "step", istep - 1, "/EM/")
}
# *************************************************************************************
# step 2: Compute the F for the new management cycle
# *************************************************************************************
dir_EM_HCR <- ifelse(istep == 1,
paste0(pdir, HS, "EM/"),
paste0(pdir, HS, HCR, OM, itr, "step", istep - 1, "/", "EM/"))
if(HCR == "HCR_staff/") step2 <- IATTCMSE::HCR_staff(dir_EM = dir_EM_HCR, istep, CurrentClosure)
if(HCR == "HCR_staff_0/") step2 <- IATTCMSE::HCR_staff_0(dir_EM = dir_EM_HCR, istep, CurrentClosure)
if(HCR == "HCR_staff_0_Fscaler/") step2 <- IATTCMSE::HCR_staff_0_Fscaler(OM, dir_EM = dir_EM_HCR, istep, CurrentClosure)
if(step2$max_gradient > 0.1) { # large gradient - the model does not converge
max_gradient_ts[istep] <- step2$max_gradient # record the gradient
Flag <- 0 # mark the flag
break
}
# save some management quantities
SBR_d_ts[istep] <- step2$SBR_d
CurrentClosure <- step2$NewClosure
Closure_ts[istep] <- step2$NewClosure
max_gradient_ts[istep] <- step2$max_gradient
Fadjust_ts[istep] <- step2$Fadjust
F30_ts[istep] <- step2$Fscale / step2$Fadjust
SB_ts[istep] <- step2$SB
# *************************************************************************************
# step 3: make projection using simulated R devs and HCR F
# *************************************************************************************
step3 <- IATTCMSE::Projection_OM(pdir, HS, HCR, OM, itr, istep, step2$Fscale, dir_OM_previous, R_devs, n_extra_R, Mcycle)
dir_istep <- step3$dir_istep
dir_OM <- step3$dir_OM
# *************************************************************************************
# Step 4: Change the data files of the updated OM to run bootstrap
# *************************************************************************************
step4 <- IATTCMSE::Bootstrap_OM(dir_istep, istep, dir_OM, Mcycle, seed, endquarter)
dir_OM_Boot <- step4
# *************************************************************************************
# Step 5: Update the OM with simulated data without error
# *************************************************************************************
step5 <- IATTCMSE::Update_OM(dir_OM, dir_OM_Boot, Mcycle, EM_comp_fleet)
# *************************************************************************************
# Step 6: Estimation model
# *************************************************************************************
# time stamp
Time_ts[istep] <- Sys.time()
if(istep < nsteps) step6 <- IATTCMSE::Estimationn_EM(dir_istep, step1$R0, dir_EM_previous, dir_OM_Boot, Mcycle, EM_comp_fleet)
}
istep
dir_OM_previous <- paste0(pdir, HS, HCR, OM, itr, "step", istep - 1, "/OM_Boot/")
dir_EM_previous <- paste0(pdir, HS, HCR, OM, itr, "step", istep - 1, "/EM/")
# *************************************************************************************
# step 2: Compute the F for the new management cycle
# *************************************************************************************
dir_EM_HCR <- ifelse(istep == 1,
paste0(pdir, HS, "EM/"),
paste0(pdir, HS, HCR, OM, itr, "step", istep - 1, "/", "EM/"))
if(HCR == "HCR_staff_0_Fscaler/") step2 <- IATTCMSE::HCR_staff_0_Fscaler(OM, dir_EM = dir_EM_HCR, istep, CurrentClosure)
if(step2$max_gradient > 0.1) { # large gradient - the model does not converge
max_gradient_ts[istep] <- step2$max_gradient # record the gradient
Flag <- 0 # mark the flag
break
}
# save some management quantities
SBR_d_ts[istep] <- step2$SBR_d
CurrentClosure <- step2$NewClosure
Closure_ts[istep] <- step2$NewClosure
max_gradient_ts[istep] <- step2$max_gradient
Fadjust_ts[istep] <- step2$Fadjust
F30_ts[istep] <- step2$Fscale / step2$Fadjust
SB_ts[istep] <- step2$SB
# *************************************************************************************
# step 3: make projection using simulated R devs and HCR F
# *************************************************************************************
step3 <- IATTCMSE::Projection_OM(pdir, HS, HCR, OM, itr, istep, step2$Fscale, dir_OM_previous, R_devs, n_extra_R, Mcycle)
dir_istep <- step3$dir_istep
dir_OM <- step3$dir_OM
# *************************************************************************************
# Step 4: Change the data files of the updated OM to run bootstrap
# *************************************************************************************
step4 <- IATTCMSE::Bootstrap_OM(dir_istep, istep, dir_OM, Mcycle, seed, endquarter)
setwd("D:/OneDrive - IATTC/Git/IATTCMSE")
devtools::document()
# step 1: create a new folder for the OM bootstrap
dir_OM_Boot <- paste0(dir_istep, "OM_Boot/")
dir.create(dir_OM_Boot)
# copy files to the new folder
files = c(
paste0(dir_OM, "starter.ss"),
paste0(dir_OM, "ss.exe"),
paste0(dir_OM, "go_nohess.bat")
)
file.copy(from = files, to = dir_OM_Boot, overwrite = TRUE)
# read the report file from the OM projection
om_out = r4ss::SS_output(dir = dir_OM, covar = F, verbose = FALSE, printstats = FALSE)
# read projected catch
Catch_projection <- r4ss::SS_ForeCatch(om_out,
yrs = ((istep - 1) * Mcycle * 4 + endquarter + 1):(istep * Mcycle * 4 + endquarter),
zeros = TRUE)
# read catch file
dat <- r4ss::SS_readdat_3.30(file = paste0(dir_OM, "BET-EPO.dat"), verbose = FALSE)
Catch <- dat$catch
Catch_projection_new <- data.frame("year" = Catch_projection$`#Year`,
"seas" = Catch_projection$Seas,
"fleet" = Catch_projection$Fleet,
"catch" = Catch_projection$`dead(B)`,
"catch_se" = 0.01)
Catch_new <- dplyr::arrange(rbind(Catch, Catch_projection_new), fleet, year)
dat$catch <- Catch_new
dat$endyr <- istep * Mcycle * 4 + endquarter
# add dummy CPUE data
CPUE_new <- dat$CPUE[(nrow(dat$CPUE) - Mcycle * 4 + 1):nrow(dat$CPUE),]
CPUE_new$year <- CPUE_new$year + Mcycle * 4
CPUE_new$se_log <- dat$CPUE$se_log[nrow(dat$CPUE)]
dat$CPUE <- rbind(dat$CPUE, CPUE_new)
# add dummy LF data
LF <- dat$sizefreq_data_list[[1]] # [which(dat$sizefreq_data_list$)]
LF_new <- LF[which((LF$year %in% 169:180) & LF$fleet %in% EM_comp_fleet),] # no LL LF during COVID years so use pre-COVID samples
LF_new$year <- LF_new$year + istep * Mcycle * 4 + 16 # 4 COVID-years (2020-2023)
dat$sizefreq_data_list[[1]] <- rbind(LF, LF_new)
dat$Nobs_per_method <- nrow(dat$sizefreq_data_list[[1]])
r4ss::SS_writedat_3.30(dat, paste0(dir_OM_Boot, "BET-EPO.dat"), verbose = FALSE, overwrite = TRUE)
# change recruitment period in the control file
ctl <- r4ss::SS_readctl_3.30(
file = paste0(dir_OM, "/BET-EPO.ctl"),
verbose = FALSE,
datlist = dat,
use_datlist = TRUE
)
ctl$MainRdevYrLast <- ctl$MainRdevYrLast + Mcycle * 4 # increase the main recruitment last year
r4ss::SS_writectl_3.30(
ctl,
outfile = paste0(dir_OM_Boot, "/BET-EPO.ctl"),
overwrite = TRUE,
verbose = FALSE
)
# change forecast file
Forecast <- r4ss::SS_readforecast(paste0(dir_OM, "forecast.ss"), verbose = FALSE)
Forecast$Nforecastyrs <- 1
r4ss::SS_writeforecast(Forecast, dir_OM_Boot, verbose = FALSE, overwrite = TRUE)
# change recruitment in the par file
ParDir <- paste0(dir_OM, "ss3.par")
ParFile <- readLines(ParDir, warn = F)
Line_main <- match("# recdev2:", ParFile)
R_main <- read.table(
file = ParDir,
nrows = 1,
skip = Line_main
)
Line_forecast <- match("# Fcast_recruitments:", ParFile)
R_forecast <- read.table(
file = ParDir,
nrows = 1,
skip = Line_forecast
)
R_main_new <- cbind(R_main, R_forecast[1,1:(Mcycle*4)])
R_forecast_new <- R_forecast[1,(Mcycle*4+1):ncol(R_forecast)]
ParFile[Line_main + 1] <- gsub(",", "", toString(R_main_new))
ParFile[Line_forecast + 1] <- gsub(",", "", toString(R_forecast_new))
writeLines(ParFile, paste0(dir_OM_Boot, "/ss3.par"))
# set up bootstrap
starter_boot <- r4ss::SS_readstarter(paste0(dir_OM_Boot, "starter.ss"), verbose = FALSE)
# specify to use the ss3.par as parameters
starter_boot$init_values_src = 1
# turn off estimation of parameters
starter_boot$last_estimation_phase = 0
# add 1 data bootstrap file
starter_boot$N_bootstraps = 3
# write new starter file
r4ss::SS_writestarter(starter_boot, dir_OM_Boot, verbose = FALSE, overwrite = TRUE)
# add a seed
starterDir <- paste0(dir_OM_Boot, "starter.ss")
starterFile <- readLines(starterDir, warn = F)
Line_seed <- match("1e-05 #_ALK_tolerance", starterFile)
starterFile[Line_seed+1] <- seed
writeLines(starterFile, paste0(dir_OM_Boot, "/starter.ss"))
istep
dir_OM_previous <- paste0(pdir, HS, HCR, OM, itr, "step", istep - 1, "/OM_Boot/")
dir_EM_previous <- paste0(pdir, HS, HCR, OM, itr, "step", istep - 1, "/EM/")
# *************************************************************************************
# step 2: Compute the F for the new management cycle
# *************************************************************************************
dir_EM_HCR <- ifelse(istep == 1,
paste0(pdir, HS, "EM/"),
paste0(pdir, HS, HCR, OM, itr, "step", istep - 1, "/", "EM/"))
if(HCR == "HCR_staff_0_Fscaler/") step2 <- IATTCMSE::HCR_staff_0_Fscaler(OM, dir_EM = dir_EM_HCR, istep, CurrentClosure)
if(step2$max_gradient > 0.1) { # large gradient - the model does not converge
max_gradient_ts[istep] <- step2$max_gradient # record the gradient
Flag <- 0 # mark the flag
break
}
# save some management quantities
SBR_d_ts[istep] <- step2$SBR_d
CurrentClosure <- step2$NewClosure
Closure_ts[istep] <- step2$NewClosure
max_gradient_ts[istep] <- step2$max_gradient
Fadjust_ts[istep] <- step2$Fadjust
F30_ts[istep] <- step2$Fscale / step2$Fadjust
SB_ts[istep] <- step2$SB
# *************************************************************************************
# step 3: make projection using simulated R devs and HCR F
# *************************************************************************************
step3 <- IATTCMSE::Projection_OM(pdir, HS, HCR, OM, itr, istep, step2$Fscale, dir_OM_previous, R_devs, n_extra_R, Mcycle)
dir_istep <- step3$dir_istep
dir_OM <- step3$dir_OM
dir_OM_previous
# set up bootstrap
starter_boot <- r4ss::SS_readstarter(paste0(dir_OM_Boot, "starter.ss"), verbose = FALSE)
# step 1: create a new folder for the OM bootstrap
dir_OM_Boot <- paste0(dir_istep, "OM_Boot/")
dir.create(dir_OM_Boot)
# copy files to the new folder
files = c(
paste0(dir_OM, "starter.ss"),
paste0(dir_OM, "ss.exe"),
paste0(dir_OM, "go_nohess.bat")
)
file.copy(from = files, to = dir_OM_Boot, overwrite = TRUE)
# read the report file from the OM projection
om_out = r4ss::SS_output(dir = dir_OM, covar = F, verbose = FALSE, printstats = FALSE)
# read projected catch
Catch_projection <- r4ss::SS_ForeCatch(om_out,
yrs = ((istep - 1) * Mcycle * 4 + endquarter + 1):(istep * Mcycle * 4 + endquarter),
zeros = TRUE)
# read catch file
dat <- r4ss::SS_readdat_3.30(file = paste0(dir_OM, "BET-EPO.dat"), verbose = FALSE)
Catch <- dat$catch
Catch_projection_new <- data.frame("year" = Catch_projection$`#Year`,
"seas" = Catch_projection$Seas,
"fleet" = Catch_projection$Fleet,
"catch" = Catch_projection$`dead(B)`,
"catch_se" = 0.01)
Catch_new <- dplyr::arrange(rbind(Catch, Catch_projection_new), fleet, year)
dat$catch <- Catch_new
dat$endyr <- istep * Mcycle * 4 + endquarter
# add dummy CPUE data
CPUE_new <- dat$CPUE[(nrow(dat$CPUE) - Mcycle * 4 + 1):nrow(dat$CPUE),]
CPUE_new$year <- CPUE_new$year + Mcycle * 4
CPUE_new$se_log <- dat$CPUE$se_log[nrow(dat$CPUE)]
dat$CPUE <- rbind(dat$CPUE, CPUE_new)
# add dummy LF data
LF <- dat$sizefreq_data_list[[1]] # [which(dat$sizefreq_data_list$)]
LF_new <- LF[which((LF$year %in% 169:180) & LF$fleet %in% EM_comp_fleet),] # no LL LF during COVID years so use pre-COVID samples
LF_new$year <- LF_new$year + istep * Mcycle * 4 + 16 # 4 COVID-years (2020-2023)
dat$sizefreq_data_list[[1]] <- rbind(LF, LF_new)
dat$Nobs_per_method <- nrow(dat$sizefreq_data_list[[1]])
r4ss::SS_writedat_3.30(dat, paste0(dir_OM_Boot, "BET-EPO.dat"), verbose = FALSE, overwrite = TRUE)
# change recruitment period in the control file
ctl <- r4ss::SS_readctl_3.30(
file = paste0(dir_OM, "/BET-EPO.ctl"),
verbose = FALSE,
datlist = dat,
use_datlist = TRUE
)
ctl$MainRdevYrLast <- ctl$MainRdevYrLast + Mcycle * 4 # increase the main recruitment last year
r4ss::SS_writectl_3.30(
ctl,
outfile = paste0(dir_OM_Boot, "/BET-EPO.ctl"),
overwrite = TRUE,
verbose = FALSE
)
# change forecast file
Forecast <- r4ss::SS_readforecast(paste0(dir_OM, "forecast.ss"), verbose = FALSE)
Forecast$Nforecastyrs <- 1
r4ss::SS_writeforecast(Forecast, dir_OM_Boot, verbose = FALSE, overwrite = TRUE)
# change recruitment in the par file
ParDir <- paste0(dir_OM, "ss3.par")
ParFile <- readLines(ParDir, warn = F)
Line_main <- match("# recdev2:", ParFile)
R_main <- read.table(
file = ParDir,
nrows = 1,
skip = Line_main
)
Line_forecast <- match("# Fcast_recruitments:", ParFile)
R_forecast <- read.table(
file = ParDir,
nrows = 1,
skip = Line_forecast
)
R_main_new <- cbind(R_main, R_forecast[1,1:(Mcycle*4)])
R_forecast_new <- R_forecast[1,(Mcycle*4+1):ncol(R_forecast)]
ParFile[Line_main + 1] <- gsub(",", "", toString(R_main_new))
ParFile[Line_forecast + 1] <- gsub(",", "", toString(R_forecast_new))
writeLines(ParFile, paste0(dir_OM_Boot, "/ss3.par"))
# set up bootstrap
starter_boot <- r4ss::SS_readstarter(paste0(dir_OM_Boot, "starter.ss"), verbose = FALSE)
View(starter_boot)
# specify to use the ss3.par as parameters
starter_boot$init_values_src = 1
# turn off estimation of parameters
starter_boot$last_estimation_phase = 0
# add 1 data bootstrap file
starter_boot$N_bootstraps = 3
starter_boot$seed
# set up bootstrap
starter_boot <- r4ss::SS_readstarter(paste0(dir_OM_Boot, "starter.ss"), verbose = FALSE)
# specify to use the ss3.par as parameters
starter_boot$init_values_src = 1
# turn off estimation of parameters
starter_boot$last_estimation_phase = 0
# add 1 data bootstrap file
starter_boot$N_bootstraps = 3
# add the seed
starter_boot$seed <- seed
